# ОБЪЯСНЕНИЕ РАБОТЫ ВИРТУАЛЬНОЙ ПАМЯТИ И ПЕРЕМЕННЫХ etext, edata, end

## Что показывает программа process_memory.c

Программа демонстрирует организацию виртуальной памяти процесса в Linux, показывая адреса различных сегментов памяти.

## Переменные etext, edata, end - что это такое?

Это **символы линковщика (linker symbols)**, которые автоматически определяются при сборке программы и указывают на границы различных сегментов памяти:

### 📍 **etext (end of text)**
- **Адрес**: CA340509 (в нашем примере)
- **Назначение**: Конец сегмента кода (text segment)
- **Содержит**: Машинный код исполняемых инструкций программы
- **Права доступа**: Только чтение и выполнение (R-X)

### 📍 **edata (end of data)**  
- **Адрес**: CA343018 (в нашем примере)
- **Назначение**: Конец сегмента инициализированных данных (data segment)
- **Содержит**: Глобальные и статические переменные с начальными значениями
- **Права доступа**: Чтение и запись (RW-)

### 📍 **end (end of BSS)**
- **Адрес**: CA343050 (в нашем примере)  
- **Назначение**: Конец сегмента неинициализированных данных (BSS segment)
- **Содержит**: Глобальные и статические переменные без начальных значений (обнуляются)
- **Права доступа**: Чтение и запись (RW-)

## Карта памяти процесса (от младших к старшим адресам):

```
┌──────────────────────────────────────────────────────┐
│                   СТЕК (Stack)                       │ ← Высокие адреса
│    Локальные переменные, параметры функций           │   C5AFF434 (переменная i)
│                        ↓                             │   C5AFF410 (buffer2)
├──────────────────────────────────────────────────────┤
│                     ...                              │
├──────────────────────────────────────────────────────┤
│                   КУЧА (Heap)                        │
│    Динамически выделяемая память (malloc)            │   FCD4F6B0 (malloc)
│                        ↑                             │
├──────────────────────────────────────────────────────┤
│                BSS СЕГМЕНТ                           │
│  Неинициализированные глобальные переменные          │
│                                               ← end  │   CA343050
├──────────────────────────────────────────────────────┤
│                DATA СЕГМЕНТ                          │
│  Инициализированные глобальные переменные            │   CA343030 (buffer1[25])
│                                                      │   CA343010 (cptr)
│                                              ← edata │   CA343018
├──────────────────────────────────────────────────────┤
│                TEXT СЕГМЕНТ                          │
│              Код программы                           │   CA340249 (main)
│                                                      │   CA34040C (showit)
│                                              ← etext │   CA340509
└──────────────────────────────────────────────────────┘ ← Низкие адреса
```

## Анализ результатов выполнения:

1. **Функции main и showit** (CA340249, CA34040C) находятся в **TEXT сегменте** - области кода
2. **Переменная cptr** (CA343010) находится в **DATA сегменте** - инициализирована строкой
3. **Массив buffer1** (CA343030) находится в **BSS сегменте** - не инициализирован 
4. **Локальные переменные i и buffer2** (C5AFF434, C5AFF410) находятся в **СТЕКЕ**
5. **Память от malloc** (FCD4F6B0) выделена в **КУЧЕ**

## Почему это важно?

- **Безопасность**: Разные сегменты имеют разные права доступа
- **Оптимизация**: Код можно разделить между процессами (shared libraries)
- **Отладка**: Понимание layout помогает в поиске ошибок
- **Управление памятью**: Знание того, где что находится, помогает в программировании

## Как проверить layout процесса:

```bash
# Во время выполнения программы в другом терминале:
cat /proc/PID/maps        # Показать карту памяти процесса
pmap PID                  # Альтернативный способ
```

## Команды для более детального изучения:

```bash
# Информация о сегментах в исполняемом файле
readelf -S process_memory
size process_memory
objdump -t process_memory | grep -E "etext|edata|end"
```